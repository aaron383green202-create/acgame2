<!DOCTYPE html>
<html lang="zh-Hant">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>雙人遊戲 3-in-1 終極版</title>
    <style>
        body { margin: 0; background: #1a1a1a; overflow: hidden; touch-action: none; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; }
        #menu { position: absolute; top: 15px; width: 100%; display: flex; justify-content: center; gap: 10px; z-index: 100; }
        button { padding: 10px 18px; font-size: 14px; background: #333; color: #fff; border: 2px solid #555; border-radius: 25px; transition: 0.3s; cursor: pointer; }
        button.active { background: #e74c3c; border-color: #fff; box-shadow: 0 0 10px rgba(231, 76, 60, 0.5); }
        #status { position: absolute; bottom: 20px; width: 100%; text-align: center; color: #fff; font-size: 22px; pointer-events: none; text-shadow: 2px 2px 4px #000; }
        canvas { display: block; filter: drop-shadow(0 0 10px rgba(0,0,0,0.5)); }
    </style>
</head>
<body>
    <div id="menu">
        <button id="btn1" class="active" onclick="switchMode(1)">1. 激鬥乒乓</button>
        <button id="btn2" onclick="switchMode(2)">2. 坦克對決</button>
        <button id="btn3" onclick="switchMode(3)">3. 合作跳躍</button>
    </div>
    <div id="status">P1: 0 | P2: 0</div>
    <canvas id="gameCanvas"></canvas>

<script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    let mode = 1; 
    let activeTouches = {};
    
    // 物件屬性
    let p1 = { x: 40, y: 0, w: 25, h: 100, score: 0, vy: 0, color: '#2ecc71' };
    let p2 = { x: 0, y: 0, w: 25, h: 100, score: 0, vy: 0, color: '#e74c3c' };
    let ball = { x: 0, y: 0, r: 10, dx: 0, dy: 0, grav: 0 };
    let tower = { x: 0, y: 0, w: 60, h: 200, hp: 5, maxHp: 5 };

    function init() {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        p2.x = canvas.width - 65;
        tower.x = canvas.width / 2 - tower.w / 2;
        tower.y = canvas.height - tower.h;
        resetPositions();
    }

    function switchMode(m) {
        mode = m;
        document.querySelectorAll('button').forEach((b, i) => b.className = (i+1 === m ? 'active' : ''));
        p1.score = 0; p2.score = 0;
        tower.hp = 5; // 重置塔的生命
        resetPositions();
    }

    function resetPositions() {
        p1.y = canvas.height/2 - p1.h/2;
        p2.y = canvas.height/2 - p2.h/2;
        p1.vy = 0; p2.vy = 0;
        ball.x = canvas.width / 2;
        ball.y = canvas.height / 2;
        
        if (mode === 1) { // 乒乓
            ball.dx = 6; ball.dy = 4; ball.grav = 0;
        } else if (mode === 2) { // 坦克
            ball.dx = 0; ball.dy = 0; ball.grav = 0.25;
        } else { // 平台跳躍
            ball.dx = 5; ball.dy = 0; ball.grav = 0;
        }
    }

    // 觸控監聽
    window.addEventListener('touchstart', e => {
        for(let t of e.changedTouches) {
            activeTouches[t.identifier] = { x: t.pageX, y: t.pageY };
            if (mode === 2) { // 坦克發射邏輯
                if (t.pageX < canvas.width/2) { 
                    ball.x = p1.x + 30; ball.y = p1.y + 20; ball.dx = 14; ball.dy = -10; 
                } else { 
                    ball.x = p2.x - 10; ball.y = p2.y + 20; ball.dx = -14; ball.dy = -10; 
                }
            }
            if (mode === 3) { // 跳躍邏輯
                if (t.pageX < canvas.width/2 && p1.y >= canvas.height - p1.h) p1.vy = -20;
                if (t.pageX >= canvas.width/2 && p2.y >= canvas.height - p2.h) p2.vy = -20;
            }
        }
    });
    window.addEventListener('touchmove', e => {
        for(let t of e.changedTouches) activeTouches[t.identifier] = { x: t.pageX, y: t.pageY };
    });
    window.addEventListener('touchend', e => {
        for(let t of e.changedTouches) delete activeTouches[t.identifier];
    });

    function update() {
        // 玩家移動處理
        if (mode !== 3) {
            for(let id in activeTouches) {
                let t = activeTouches[id];
                if (t.x < canvas.width/2) p1.y = t.y - p1.h/2;
                else p2.y = t.y - p2.h/2;
            }
        } else {
            p1.vy += 1; p2.vy += 1;
            p1.y += p1.vy; p2.y += p2.vy;
            if (p1.y > canvas.height - p1.h) { p1.y = canvas.height - p1.h; p1.vy = 0; }
            if (p2.y > canvas.height - p2.h) { p2.y = canvas.height - p2.h; p2.vy = 0; }
        }

        // 球/砲彈物理
        ball.dy += ball.grav;
        ball.x += ball.dx;
        ball.y += ball.dy;

        // 邊界碰撞
        if (ball.y < 0 || ball.y > canvas.height) ball.dy *= -0.9;

        // 玩家碰撞檢測
        if (checkRect(ball, p1)) {
            if (mode === 2) { p2.score++; resetPositions(); }
            else { ball.dx = Math.abs(ball.dx); }
        }
        if (checkRect(ball, p2)) {
            if (mode === 2) { p1.score++; resetPositions(); }
            else { ball.dx = -Math.abs(ball.dx); }
        }

        // 高塔碰撞 (僅限模式 2)
        if (mode === 2 && tower.hp > 0) {
            if (ball.x > tower.x && ball.x < tower.x + tower.w && ball.y > tower.y) {
                tower.hp--;
                resetPositions();
            }
        }

        // 得分與重置
        if (ball.x < 0) { p2.score++; resetPositions(); }
        if (ball.x > canvas.width) { p1.score++; resetPositions(); }
        
        document.getElementById('status').innerText = `P1: ${p1.score} | P2: ${p2.score}`;
    }

    function checkRect(b, r) {
        return b.x > r.x && b.x < r.x + r.w && b.y > r.y && b.y < r.y + r.h;
    }

    function draw() {
        ctx.fillStyle = 'rgba(20, 20, 20, 0.4)'; // 拖尾效果
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        // 畫高塔 (模式 2)
        if (mode === 2 && tower.hp > 0) {
            ctx.fillStyle = '#5d4037';
            ctx.fillRect(tower.x, tower.y, tower.w, tower.h);
            // 血條
            ctx.fillStyle = '#ff0000';
            ctx.fillRect(tower.x, tower.y - 15, tower.w, 6);
            ctx.fillStyle = '#00ff00';
            ctx.fillRect(tower.x, tower.y - 15, tower.w * (tower.hp / tower.maxHp), 6);
        }

        // 畫玩家與球
        ctx.fillStyle = p1.color; ctx.fillRect(p1.x, p1.y, p1.w, p1.h);
        ctx.fillStyle = p2.color; ctx.fillRect(p2.x, p2.y, p2.w, p2.h);
        ctx.fillStyle = '#f1c40f'; 
        ctx.beginPath(); ctx.arc(ball.x, ball.y, ball.r, 0, Math.PI*2); ctx.fill();

        update();
        requestAnimationFrame(draw);
    }

    window.addEventListener('resize', init);
    init(); draw();
</script>
</body>
</html>
